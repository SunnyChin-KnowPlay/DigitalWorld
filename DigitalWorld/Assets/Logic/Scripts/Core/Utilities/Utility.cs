using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
using System.IO;
using DigitalWorld.Logic.Properties;
using System.Security.Cryptography;
using System.Text;

#if UNITY_EDITOR
using UnityEditor;
#endif


namespace DigitalWorld.Logic
{
    public enum EItemType
    {
        Action,
        Property,
        Event,
    }

    public static class Utility
    {
        #region Params
        private const string ConfigsRelativePath = "Configs";
        private const string TriggersRelativePath = "Triggers";
        private const string LevelsRelativePath = "Levels";

        public const string ProjectNamespace = "DigitalWorld";

        private const string LogicAssetPath = "Assets/Logic";
        public const string ConfigsPath = LogicAssetPath + "/" + ConfigsRelativePath;
        public const string TemplateConfigsPath = ConfigsPath + "/" + "Template";

        public const string ScriptPath = LogicAssetPath + "/" + "Scripts";
        public const string GeneratedScriptPath = ScriptPath + "/" + "Generated";
        public const string ImplementScriptPath = ScriptPath + "/" + "Implements";
        public const string TriggerPath = ConfigsPath + "/" + TriggersRelativePath;
        public const string LevelPath = ConfigsPath + "/" + LevelsRelativePath;

        public const string GeneratedTips = @"// ------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//  
//     对此文件的更改可能导致不正确的行为，如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
// ------------------------------------------------------------------------------";

        internal const string LogicResPath = "Assets/Res/Logic";

        public static Dictionary<string, int> KeyDict = new Dictionary<string, int>();

        public const string ActionName = "Actions";
        public const string PropertyName = "Properties";
        public const string EventName = "Events";
        /// <summary>
        /// 逻辑命名空间
        /// </summary>
        public const string LogicNamespace = ProjectNamespace + ".Logic";
        public readonly static string[] usingNamespaces = new string[6] { ProjectNamespace + ".Game", LogicNamespace + "." + PropertyName, "UnityEngine", "System", "Dream", "Dream.Core" };

        public const string LogicActionNamespace = LogicNamespace + "." + ActionName;
        public const string LogicEventNamespace = LogicNamespace + "." + EventName;
        public const string LogicPropertyNamespace = LogicNamespace + "." + PropertyName;

        private static Assembly csharpAss = null;

        public static Color kSplitLineColor;
        public const float splitSpaceWidth = 4f;
        #endregion
#if UNITY_EDITOR
        #region Settings
        public const string nodeDefaultEditingKey = LogicNamespace + "." + "NodeDefaultEditing";
        public const string runningWindowAutoOpenKey = LogicNamespace + "." + "RunningWindowAutoOpen";

        /// <summary>
        /// 节点是否为默认开启编辑状态
        /// </summary>
        public static bool NodeDefaultEditing
        {
            get
            {
                bool v = EditorPrefs.HasKey(nodeDefaultEditingKey);
                if (!v)
                    EditorPrefs.SetBool(nodeDefaultEditingKey, true);

                return EditorPrefs.GetBool(nodeDefaultEditingKey);
            }
            set
            {
                EditorPrefs.SetBool(nodeDefaultEditingKey, value);
            }
        }

        public static bool RunningWindowAutoOpen
        {
            get
            {
                bool v = EditorPrefs.HasKey(runningWindowAutoOpenKey);
                if (!v)
                    EditorPrefs.SetBool(runningWindowAutoOpenKey, false);

                return EditorPrefs.GetBool(runningWindowAutoOpenKey);
            }
            set
            {
                EditorPrefs.SetBool(runningWindowAutoOpenKey, value);
            }
        }
        #endregion
#endif

        #region Common
        static Utility()
        {
            kSplitLineColor = new Color(0.12f, 0.12f, 0.12f, 0.62f);
        }

#if UNITY_EDITOR
        public static GUIStyle StyleD__MenuIconButton
        {
            get
            {
                GUIStyle gUIStyle = GUI.skin.FindStyle("IconButton") ?? EditorGUIUtility.GetBuiltinSkin(EditorSkin.Inspector).FindStyle("IconButton");
                if (null != gUIStyle)
                {
                    gUIStyle.margin.top = 2;
                }

                return gUIStyle;
            }
        }

        public static GUIContent GUIContentD__Menu
        {
            get
            {
                return EditorGUIUtility.IconContent("d__Menu");
            }
        }

        public static TextAsset LoadTemplateConfig(string path)
        {
            if (string.IsNullOrEmpty(path))
                return null;

            string folderPath = TemplateConfigsPath;
            if (!Directory.Exists(folderPath))
                return null;
            string fullPath = folderPath + "/" + path + ".xml";

            return (TextAsset)AssetDatabase.LoadAssetAtPath(fullPath, typeof(TextAsset));
        }

        public static TextAsset LoadConfig(string path)
        {
            if (string.IsNullOrEmpty(path))
                return null;

            string folderPath = ConfigsPath;
            if (!Directory.Exists(folderPath))
                return null;
            string fullPath = folderPath + "/" + path + ".asset";

            return (TextAsset)AssetDatabase.LoadAssetAtPath(fullPath, typeof(TextAsset));
        }

        /// <summary>
        /// 获取当前选择的文件夹路径
        /// </summary>
        /// <returns></returns>
        public static string GetSelectionFolderPath()
        {
            string[] guid = Selection.assetGUIDs;
            if (null == guid || guid.Length <= 0)
            {
                UnityEngine.Debug.LogError("请先选择一个文件/文件夹");
                return string.Empty;
            }

            return AssetDatabase.GUIDToAssetPath(guid[0]);
        }

        public static void ClearDirectory(string path)
        {
            if (!Directory.Exists(path))
                return;

            string[] files = Directory.GetFiles(path);
            for (int i = 0; i < files.Length; ++i)
            {
                File.Delete(files[i]);
            }

            string[] directories = Directory.GetDirectories(path);
            for (int i = 0; i < directories.Length; ++i)
            {
                if (Directory.Exists(directories[i]))
                {
                    ClearDirectory(directories[i]);
                    Directory.Delete(directories[i]);
                }
            }

        }

        public static void SaveDataToFile(string data, string filePath, FileMode mode = FileMode.Create)
        {
            string folderPath = System.IO.Path.GetDirectoryName(filePath);
            if (!Directory.Exists(folderPath))
            {
                Directory.CreateDirectory(folderPath);
            }

            FileStream stream = File.Open(filePath, mode);
            StreamWriter writer = new StreamWriter(stream);
            writer.Write(data);
            writer.Flush();
            writer.Close();
            stream.Close();
        }

        /// <summary>
        /// 写入byte流到文件
        /// </summary>
        /// <param name="data"></param>
        /// <param name="size"></param>
        /// <param name="filePath"></param>
        /// <param name="mode"></param>
        public static void SaveDataToFile(byte[] data, int size, string filePath, FileMode mode = FileMode.Create)
        {
            string folderPath = System.IO.Path.GetDirectoryName(filePath);
            if (!Directory.Exists(folderPath))
            {
                Directory.CreateDirectory(folderPath);
            }

            FileStream stream = File.Open(filePath, mode);
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(data, 0, size);
            writer.Flush();
            writer.Close();
            stream.Close();
        }

        /// <summary>
        /// 获取自己的名字 就是说 取最后一个.后面的名字
        /// </summary>
        /// <param name="fullName"></param>
        /// <returns></returns>
        public static string GetSelfName(string fullName)
        {
            if (string.IsNullOrEmpty(fullName))
                return fullName;
            if (!fullName.Contains('.'))
                return fullName;

            return fullName.Substring(fullName.LastIndexOf('.') + 1);
        }

        /// <summary>
        /// 获取标准化枚举命名
        /// 将所有的 . 以及 / 替换成 _ 
        /// 因为枚举是只可以使用 _ 符号的
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public static string GetStandardizationEnumName(string name)
        {
            name = name.Replace('.', '_');
            name = name.Replace('/', '_');
            return name;
        }

        /// <summary>
        /// 获取标准化的命名空间名字
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public static string GetStandardizationNamespaceName(string name)
        {
            name = name.Replace('_', '.');
            name = name.Replace('/', '.');
            return name;
        }

        /// <summary>
        /// 获取基于文件夹的名字
        /// </summary>
        /// <param name="name">标准命名空间的名字</param>
        /// <returns></returns>
        public static string GetDirectoryFileName(string name)
        {
            return name.Replace('.', '/');
        }

        /// <summary>
        /// 获取项目文件路径 Application.dataPath移除"/Assets"
        /// </summary>
        /// <returns></returns>
        public static string GetProjectDataPath()
        {
            string p = Application.dataPath.Replace("/Assets", "");
            return p;
        }

        public static string ToUpperFirst(this string s)
        {
            if (String.IsNullOrEmpty(s))
            {
                return s;
            }

            return char.ToUpper(s[0]) + s.Substring(1);
        }

        /// <summary>
        /// 通过.来组合命名 用在命名空间上
        /// </summary>
        /// <param name="name1">命名空间前缀</param>
        /// <param name="name2">相对自身的命名空间</param>
        /// <returns></returns>
        public static string CombineName(string name1, string name2)
        {
            string ret = "";

            if (!string.IsNullOrEmpty(name1))
            {
                ret += name1;
            }

            if (!string.IsNullOrEmpty(name1) && !string.IsNullOrEmpty(name2))
            {
                ret += '.';
            }

            if (!string.IsNullOrEmpty(name2))
            {
                ret += name2;
            }

            return ret;
        }



        /// <summary>
        /// 获取命名空间的名字
        /// 即最后一个点之前的名字
        /// </summary>
        /// <param name="fullName"></param>
        /// <returns></returns>
        public static string GetNamespaceName(string fullName)
        {
            if (string.IsNullOrEmpty(fullName))
                return fullName;
            if (!fullName.Contains('.'))
                return string.Empty;

            return fullName.Substring(0, fullName.LastIndexOf('.'));
        }

        public static NodeBase CreateNewAction(EAction action)
        {
            string name = string.Format("{0}.{1}", LogicActionNamespace, GetStandardizationNamespaceName(action.ToString()));
            System.Type type = GetTemplateType(name);
            if (null == type)
                return null;
            NodeBase node = System.Activator.CreateInstance(type) as NodeBase;
            if (node is Actions.ActionBase ab)
            {
                ab.OnCreate();
            }
            return node;
        }

        public static Properties.PropertyBase CreateNewProperty(Type type)
        {
            PropertyBase node = System.Activator.CreateInstance(type) as PropertyBase;

            return node;
        }
        public static Type GetTemplateType(string name)
        {
            Type t = null;

            if (null != csharpAss)
            {
                Type tt = csharpAss.GetType(name);
                if (tt != null)
                {
                    t = tt;
                }
            }
            if (null == t)
            {
                var assemblies = AppDomain.CurrentDomain.GetAssemblies();
                foreach (var asm in assemblies)
                {
                    Type tt = asm.GetType(name);
                    if (tt != null)
                    {
                        csharpAss = asm;
                        t = tt;
                        break;
                    }
                }
            }

            return t;
        }

        /// <summary>
        /// 在CurrentDomain下获取所有的枚举类型数组
        /// </summary>
        /// <returns></returns>
        public static List<Type> GetPublicEnumTypes(List<Type> list)
        {
            if (null == list)
                list = new List<Type>();

            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (Assembly asm in assemblies)
            {
                Type[] types = asm.GetTypes();
                foreach (Type type in types)
                {
                    if (type.IsEnum && type.IsPublic)
                    {
                        string namespaceName = type.Namespace;
                        if (!string.IsNullOrEmpty(namespaceName) && namespaceName.Contains(ProjectNamespace))
                        {
                            list.Add(type);
                        }
                    }
                }
            }

            return list;
        }

        private static bool CheckIsUnderlyingType(Type type)
        {
            foreach (ETypeCode c in System.Enum.GetValues(typeof(ETypeCode)))
            {
                if (type.Name == c.ToString())
                    return true;
            }
            return false;
        }

        public static List<Type> GetUnderlyingTypes(List<Type> list)
        {
            if (null == list)
                list = new List<Type>();

            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (Assembly asm in assemblies)
            {
                Type[] types = asm.GetTypes();
                foreach (Type type in types)
                {
                    if (type.IsPublic && CheckIsUnderlyingType(type))
                    {
                        list.Add(type);

                    }
                }
            }

            return list;
        }

        public static string GetLocalName(string fullName)
        {
            if (string.IsNullOrEmpty(fullName))
                return fullName;

            if (!fullName.Contains('.'))
                return fullName;

            if (!fullName.Contains(Utility.LogicNamespace))
                return fullName;

            return fullName.Substring(fullName.IndexOf(Utility.LogicNamespace) + Utility.LogicNamespace.Length + 1);
        }

        public static string GetPropertyLocalName(string fullName)
        {
            string name = GetLocalName(fullName);

            string propertyNamespaceName = Utility.PropertyName + '.';
            if (name.Contains(propertyNamespaceName))
            {
                name = name.Substring(propertyNamespaceName.Length);
            }

            return name;
        }
#endif
        #endregion

        #region AES
        private const string keyStr = "&*^^^*&&HKJHHK&&";

        public static byte[] GetMd5NN(string str)
        {
            byte[] byteHashedPassword;
            using (MD5 md5 = MD5.Create())
            {
                byteHashedPassword = md5.ComputeHash(Encoding.UTF8.GetBytes(str));
            }
            return byteHashedPassword;
        }

        public static byte[] AESEncrypt(byte[] inputBuffer, int inputOffset, int inputCount, byte[] key, out bool result)
        {
            try
            {

                byte[] ivArray = GetMd5NN("有本事你就解");

                RijndaelManaged rDel = new RijndaelManaged();
                rDel.Key = key;
                rDel.IV = ivArray;
                rDel.Mode = CipherMode.CBC;
                rDel.Padding = PaddingMode.PKCS7;

                ICryptoTransform cTransform = rDel.CreateEncryptor();
                byte[] resultArray = cTransform.TransformFinalBlock(inputBuffer, inputOffset, inputCount);
                result = true;
                return resultArray;
            }
            catch (System.Exception ex)
            {

            }
            result = true;
            return null;
        }

        public static byte[] AESDecrypt(byte[] inputBuffer, int inputOffset, int inputCount, byte[] key, out bool result)
        {
            try
            {

                byte[] ivArray = GetMd5NN("有本事你就解");

                RijndaelManaged rDel = new RijndaelManaged();
                rDel.Key = key;
                rDel.IV = ivArray;
                rDel.Mode = CipherMode.CBC;
                rDel.Padding = PaddingMode.PKCS7;
                ICryptoTransform cTransform = rDel.CreateDecryptor();
                byte[] resultArray = cTransform.TransformFinalBlock(inputBuffer, inputOffset, inputCount);
                result = true;
                return resultArray;
            }
            catch (System.Exception ex)
            {

            }
            result = false;
            return null;
        }

        public static byte[] GetKey()
        {
            byte[] key = GetMd5NN(keyStr);
            return key;
        }
        #endregion

        #region Font
#if UNITY_EDITOR
        private static Font editorSkinFont = null;
        public static Font EditorSkinFont
        {
            get
            {
                if (null == editorSkinFont)
                {
                    editorSkinFont = AssetDatabase.LoadAssetAtPath<Font>("Assets/Art/UI/Font/EditorSkin.ttf");
                }
                return editorSkinFont;
            }
        }
#endif
        #endregion
    }
}
